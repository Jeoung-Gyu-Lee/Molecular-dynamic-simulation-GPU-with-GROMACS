# -*- coding: utf-8 -*-
"""MD simulation(GPU).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18rkOKSJ1Z4FVSIfI8mSYSXgLvwuBPzco

#Install dependencies and required packages
**GROMACS needs to be built only once. After that, reuse the saved tar.gz package**
"""

#@title **Mount google drive**
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# #@title **Install cmake and gromacs for GPU build**
# # GROMACS needs to be built only once. After that, reuse the saved tar.gz package
# %%bash
# apt-get update
# apt-get install -y build-essential cmake pkg-config libfftw3-dev libxml2-dev zlib1g-dev
# 
# # Download GROMACS 2025.2 source, GPU bulid
# wget https://ftp.gromacs.org/pub/gromacs/gromacs-2025.2.tar.gz
# tar -xzf gromacs-2025.2.tar.gz
# 
# # Create build directory
# mkdir gromacs-2025.2/build
# cd gromacs-2025.2/build
# 
# # Configure with CMake, SIMD is AVX2_256
# cmake .. \
#   -DGMX_SIMD=AVX2_256 \
#   -DGMX_CPU_DISPATCH=ON \
#   -DGMX_GPU=CUDA \
#   -DGMX_BUILD_OWN_FFTW=ON \
#   -DREGRESSIONTEST_DOWNLOAD=ON
# 
# # Build GROMACS (using 2 cores, adjust if needed)
# make -j 2
# make install
# 
# # # Save the GROMACS build with GPU support as a tar file in my Drive for later reuse
# tar -czvf /content/drive/MyDrive/gromacs-2025.2-gpu.tar.gz /usr/local/gromacs
# 
# # Source the GMXRC file to make GROMACS commands available in the current shell
# source /usr/local/gromacs/bin/GMXRC
# 
# # Verify GROMACS installation
# gmx --version

#@title **Install Conda Colab**
!pip install -q condacolab
import condacolab
condacolab.install()

# Commented out IPython magic to ensure Python compatibility.
# #@title **Install packages and dependencies**
# %%bash
# apt-get update
# apt-get -y install openbabel
# apt-get install -y libhdf4-0 libhdf4-dev
# mamba create -n amber -c conda-forge python=3.11 ambertools hdf5 openbabel acpype -y
# conda install -c conda-forge openmm biopython pdbfixer

# Commented out IPython magic to ensure Python compatibility.
# #@title **Reuse the saved tar.gz package**
# %%bash
# tar -xzvf /content/drive/MyDrive/gromacs-2025.2-gpu.tar.gz -C /
# source /usr/local/gromacs/bin/GMXRC
# gmx --version

#@title **GPU Check in Colab**
import os
import subprocess

!lscpu
try:
    gpu = subprocess.check_output(["nvidia-smi"]).decode()
    print(gpu)
except FileNotFoundError:
    print('Select the Runtime > "Change runtime type" menu to enable a GPU accelerator,')
    print('and then re-execute this cell.')

#@title **Create folder**
#@markdown Enter a **[ Project Name ]** without space.\
#@markdown This creates a folder for MD simulation.
import os

Project_name = "Epicatechingallate" #@param {type:"string"}Cosmosiin
assert not Project_name == "", "Do not leave this blank."
assert not any(c == "/" or c == "." for c in Project_name), "Disallowed characters."

DIR = "/content/drive/MyDrive"
PROJECT_DIR = os.path.join(DIR, Project_name)

if os.path.exists(PROJECT_DIR):
    print(f"+ {os.path.basename(PROJECT_DIR)} folder already exists")
# Changed os.mkdir to os.makedirs to create intermediate directories
if not os.path.exists(PROJECT_DIR):
    os.makedirs(PROJECT_DIR)
    print(f"+ {os.path.basename(PROJECT_DIR)} folder created")

os.chdir(PROJECT_DIR) # Working directory

#@title **Prepare receptor topology**
#@markdown "Use ligand pose obtained from docking<br>
#@markdown "Before upload, delete lines of ligand and conect in pdb file<br>
#@markdown "Then upload complex.pdb file
from google.colab import files
uploaded = files.upload()
os.rename(list(uploaded.keys())[0], "receptor.pdb")

# Remove 'HETATM' for dokcing
!grep -v "UNL"  receptor.pdb > receptor_clean.pdb

# Commented out IPython magic to ensure Python compatibility.
# #@title **Fix missing atoms/residues with PDBFixer**
# %%bash
# # Activate the base conda environment
# eval "$(conda shell.bash hook)"
# conda activate base
# 
# in_pdb="receptor_clean.pdb"
# out_pdb="receptor_fixer.pdb"
# 
# # Write the Python script to a file
# cat > run_pdbfixer.py << EOF
# from pdbfixer import PDBFixer
# from openmm.app import PDBFile
# import os
# 
# # Use the cleaned PDB file
# in_pdb  = os.environ.get("CLEANED_PDB")
# out_pdb = os.environ.get("OUT_PDB")
# 
# fixer = PDBFixer(filename=in_pdb)
# fixer.findMissingResidues()
# fixer.findMissingAtoms()
# fixer.addMissingAtoms()
# fixer.addMissingHydrogens(pH=7.0)
# 
# with open(out_pdb, 'w') as f:
#     PDBFile.writeFile(fixer.topology, fixer.positions, f)
# print("Wrote", out_pdb)
# EOF
# 
# export CLEANED_PDB="$in_pdb"
# export OUT_PDB="$out_pdb"
# 
# # Run the Python script within the activated conda environment
# python run_pdbfixer.py

# Commented out IPython magic to ensure Python compatibility.
# # Generate the protein topology using the Amber 99sb force field and TIP3P water model
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx pdb2gmx -f receptor_fixer.pdb -o protein.gro -ff amber99sb -water tip3p -ignh

#@title **Prepare ligand topology**
# Upload the PDB file containing both receptor and ligand
from google.colab import files
uploaded = files.upload()
os.rename(list(uploaded.keys())[0], "complex.pdb")
!grep -E '^(ATOM|HETATM).*[[:space:]]UNL([[:space:]]|$)|^CONECT' complex.pdb > ligand.pdb

# Add Hydrogens and Adjust pH using Open Babel (Split Steps),
# This adds BOTH polar (with ph 7.4) and non-polar hydrogens.
!obabel ligand.pdb -O ligand_clean.pdb -h -p 7.4

# Add AmberTools 'bin' and 'lib' directories to PATH and LD_LIBRARY_PATH so executables and shared libraries can be found
os.environ["PATH"] = "/usr/local/envs/amber/bin:" + os.environ.get("PATH","")
os.environ["LD_LIBRARY_PATH"] = "/usr/local/envs/amber/lib:" + os.environ.get("LD_LIBRARY_PATH","")

!acpype -i ligand_clean.pdb -b UNL -a gaff2 -c bcc -n 0 -m 1
!cp UNL.acpype/UNL_GMX.itp $PROJECT_DIR/
!cp UNL.acpype/UNL_GMX.gro $PROJECT_DIR/

# Commented out IPython magic to ensure Python compatibility.
# #@title **Remove numeric suffixes (from acpype) for a GROMACS ITP**
# %%bash
# awk '
# BEGIN{inside=0}
# # Enter the [ atoms ] block
# /^[[:space:]]*\[[[:space:]]*atoms[[:space:]]*\]/{inside=1; print; next}
# inside && /^[[:space:]]*\[/{inside=0; print; next}
# 
# inside{
#   # Pass through comments or empty lines unchanged
#   if ($0 ~ /^[[:space:]]*;/ || $0 ~ /^[[:space:]]*$/) { print; next }
#   ## Remove trailing digits from the 5th field (atom name), e.g., C1->C
#   if ($1 ~ /^[0-9]+$/ && NF >= 6) {
#     sub(/[0-9]+$/, "", $5)
#   }
#   print; next
# }
# { print }
# ' UNL_GMX.itp > UNL_GMX_nonum.itp

"""**[REFERENCE NOTE] include the ligand in topol.top (not a command)**<br>
1) Add the ligand .itp include below the forcefield includes:
   ; Include forcefield parameters
   #include "forcefield.itp"

   ; === Ligand topology ===<br>
   #include "UNL_GMX_nonum.itp"   ; ← Add this line
<br>

2) Declare the molecule counts at the bottom:<br>
   (must match [ moleculetype ] name in UNL_GMX_nonum.itp)

   [ molecules ]
   Protein    1
   UNL        1   ; ← Add this line

"""

# Commented out IPython magic to ensure Python compatibility.
# #@title **Build complex using protein and ligand pdb files**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx editconf -f protein.gro -o protein.pdb
# awk '/^(ATOM  |HETATM|TER)/{print}' protein.pdb > complex.pdb
# grep -E '^(ATOM  |HETATM)' ligand_clean.pdb >> complex.pdb
# echo "END" >> complex.pdb
# gmx editconf -f complex.pdb -o complex.gro

# Commented out IPython magic to ensure Python compatibility.
# #@title **Define the unit cell and fill it with water**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx editconf -f complex.gro -o newbox.gro -bt dodecahedron -d 1.0

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx solvate -cp newbox.gro -cs tip3p.gro -p topol.top -o solv.gro

# Commented out IPython magic to ensure Python compatibility.
# #@title **Add ions using any .mdp file**
# %%bash
# cat > "ions.mdp" <<EOF
# ; ions.mdp — placeholder for genion (EM-style params)
# integrator      = steep
# emtol           = 1000.0
# emstep          = 0.01
# nsteps          = 500
# 
# cutoff-scheme   = Verlet
# nstlist         = 10
# coulombtype     = PME
# rcoulomb        = 1.0
# rvdw            = 1.0
# pbc             = xyz
# EOF

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx grompp -f ions.mdp -c solv.gro -p topol.top -o ions.tpr -maxwarn 1

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# echo "15" | gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral

#@title **Energy minimization using em.mdp**
import os
import ipywidgets as W
from IPython.display import display, Markdown

# Widgets for core parameters
integrator = W.Dropdown(options=["steep", "cg"], value="steep", description="Integrator:")
emtol      = W.FloatText(value=1000.0, description="emtol:")
emstep     = W.FloatText(value=0.01, description="emstep:")
nsteps     = W.IntText(value=50000, description="nsteps:")
button     = W.Button(description="Write em.mdp", button_style="success")

out = W.Output()

def write_file(_):
    text = f"""
; em.mdp — energy minimization
integrator    = {integrator.value}
emtol         = {emtol.value}
emstep        = {emstep.value}
nsteps        = {nsteps.value}

; typical defaults
cutoff-scheme = Verlet
nstlist       = 10
coulombtype   = PME
rcoulomb      = 1.0
rvdw          = 1.0
pbc           = xyz
"""
    path = os.path.join(PROJECT_DIR, "em.mdp")
    with open(path, "w") as f:
        f.write(text.strip()+"\n")
    out.clear_output()
    with out:
        display(Markdown(f"✅ **Saved:** `{path}`"))
        display(Markdown("```mdp\n"+text.strip()+"\n```"))

button.on_click(write_file)
display(W.VBox([integrator, emtol, emstep, nsteps, button, out]))

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx grompp -f em.mdp -c solv_ions.gro -p topol.top -o em.tpr

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx mdrun -deffnm em -v -nb auto -pme cpu -pin off -ntmpi 1 -ntomp 2

# Commented out IPython magic to ensure Python compatibility.
# #@title **Energy Minimization Convergence**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "10 0" | gmx energy -f em.edr -o potential.xvg

import matplotlib.pyplot as plt

x, y = [], []
with open("potential.xvg") as f:
    for line in f:
        if line.startswith(("#", "@")):
            continue
        step, energy = map(float, line.split())
        x.append(step)
        y.append(energy)

plt.figure(figsize=(6,4))
plt.plot(x, y, lw=1.5)
plt.xlabel("Minimization Step")
plt.ylabel("Potential Energy (kJ/mol)")
plt.title("Energy Minimization Convergence")
plt.grid(True)
plt.show()

#@title **Equilibration with NVT, NPT using mdp file**
# Generate a mdp file for nvt and npt stpes
# === Minimal widgets to write NVT/NPT mdp files (core params only) ===
import os, textwrap
import ipywidgets as W
from IPython.display import display, Markdown

### NVT core params ###
nvt_dt     = W.FloatText(value=0.002, description="dt (ps):")          # 2 fs
nvt_steps  = W.IntText(value=50000, description="nsteps:")             # 100 ps
nvt_temp   = W.FloatText(value=300.0, description="ref-T (K):")
nvt_tau_t  = W.FloatText(value=0.5, description="tau-T:")
nvt_posres = W.Checkbox(value=True, description="Apply POSRES (protein)")

### NPT core params ###
npt_dt     = W.FloatText(value=0.002, description="dt (ps):")
npt_steps  = W.IntText(value=50000, description="nsteps:")
npt_temp   = W.FloatText(value=300.0, description="ref-T (K):")
npt_tau_t  = W.FloatText(value=0.5, description="tau-T:")
npt_ref_p  = W.FloatText(value=1.0, description="ref-P (bar):")
npt_tau_p  = W.FloatText(value=5.0, description="tau-P:")
npt_iso    = W.Dropdown(options=[("isotropic","isotropic")],
                        value="isotropic", description="pcoupltype:")
npt_posres = W.Checkbox(value=True, description="Apply POSRES (protein)")

write_btn  = W.Button(description="Write nvt.mdp & npt.mdp", button_style="success", icon="save")
out        = W.Output()

def _nvt_text():
    define_flag = "-DPOSRES" if nvt_posres.value else ""
    txt = f"""
    ; NVT equilibration (core params from widget)
    integrator      = md
    dt              = {nvt_dt.value}
    nsteps          = {nvt_steps.value}

    ; Output control
    nstxout         = 0
    nstvout         = 0
    nstfout         = 0
    nstlog          = 1000
    nstenergy       = 1000
    nstxout-compressed = 1000

    ; Neighbor searching & cutoffs (typical defaults)
    cutoff-scheme   = Verlet
    nstlist         = 20
    rcoulomb        = 1.0
    rvdw            = 1.0
    coulombtype     = PME

    ; Constraints
    constraints     = h-bonds

    ; Thermostat
    tcoupl          = V-rescale
    tc-grps         = Protein Non-Protein
    tau-t           = {nvt_tau_t.value:.3f}     {nvt_tau_t.value:.3f}
    ref-t           = {nvt_temp.value:.1f}     {nvt_temp.value:.1f}

    ; Barostat (off in NVT)
    pcoupl          = no

    ; Misc
    pbc             = xyz
    DispCorr        = EnerPres
    gen-vel         = yes
    gen-temp        = {nvt_temp.value:.1f}
    gen-seed        = -1
    define          = {define_flag}
    """
    return textwrap.dedent(txt).strip() + "\n"

def _npt_text():
    define_flag = "-DPOSRES" if npt_posres.value else ""
    refcoord_scaling_option = "refcoord_scaling = com" if npt_posres.value else ""
    txt = f"""
    ; NPT equilibration (core params from widget)
    integrator      = md
    dt              = {npt_dt.value}
    nsteps          = {npt_steps.value}

    ; Output control
    nstxout         = 0
    nstvout         = 0
    nstfout         = 0
    nstlog          = 1000
    nstenergy       = 1000
    nstxout-compressed = 1000

    ; Neighbor searching & cutoffs (typical defaults)
    cutoff-scheme   = Verlet
    nstlist         = 20
    rcoulomb        = 1.0
    rvdw            = 1.0
    coulombtype     = PME

    ; Constraints
    constraints     = h-bonds
    lincs-iter      = 1
    lincs-order     = 4

    ; Thermostat
    tcoupl          = V-rescale
    tc-grps         = Protein Non-Protein
    tau-t           = {npt_tau_t.value:.3f}     {npt_tau_t.value:.3f}
    ref-t           = {npt_temp.value:.1f}     {npt_temp.value:.1f}

    ; Barostat
    pcoupl          = C-rescale
    pcoupltype      = {npt_iso.value}
    tau-p           = {npt_tau_p.value:.3f}
    ref-p           = {npt_ref_p.value:.3f}
    compressibility = 4.5e-5
    {refcoord_scaling_option}

    ; Misc
    pbc             = xyz
    DispCorr        = EnerPres
    gen-vel         = no
    define          = {define_flag}
    """
    return textwrap.dedent(txt).strip() + "\n"

def write_files(_):
    nvt_path = os.path.join(PROJECT_DIR, "nvt.mdp")
    npt_path = os.path.join(PROJECT_DIR, "npt.mdp")
    with open(nvt_path, "w") as f: f.write(_nvt_text())
    with open(npt_path, "w") as f: f.write(_npt_text())
    out.clear_output()
    with out:
        display(Markdown(f"✅ **Saved:** `{nvt_path}` & `{npt_path}`"))
        display(Markdown("**nvt.mdp**"))
        display(Markdown("```mdp\n"+_nvt_text()+"```"))
        display(Markdown("**npt.mdp**"))
        display(Markdown("```mdp\n"+_npt_text()+"```"))

write_btn.on_click(write_files)

nvt_box = W.VBox([W.HTML("<b>NVT core parameters</b>"),
                  nvt_dt, nvt_steps, nvt_temp, nvt_tau_t, nvt_posres])
npt_box = W.VBox([W.HTML("<b>NPT core parameters</b>"),
                  npt_dt, npt_steps, npt_temp, npt_tau_t, npt_ref_p, npt_tau_p, npt_iso, npt_posres])

display(W.VBox([
    W.HTML(f"<h3>Generate mdp files for NVT and NPT equilibration</h3>"
           f"<small>Target folder: <code>{PROJECT_DIR}</code></small>"),
    W.HBox([nvt_box, W.HTML("&nbsp;&nbsp;&nbsp;"), npt_box]),
    write_btn,
    out
]))

# Commented out IPython magic to ensure Python compatibility.
# # NVT step
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -o nvt.tpr

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx mdrun -deffnm nvt -v -nb auto -pme gpu -pin off -ntmpi 1 -ntomp 2

# Commented out IPython magic to ensure Python compatibility.
# # NPT step
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# gmx mdrun -deffnm npt -v -nb auto -pme gpu -pin off -ntmpi 1 -ntomp 2

#@title **Run production MD using md.mdp file**
# Generate a md.mdp\
import os, textwrap
import ipywidgets as W
from IPython.display import display, Markdown

# Widgets for core parameters
dt      = W.FloatText(value=0.002, description="dt (ps):")        # 2 fs
nsteps  = W.IntText(value=50000000, description="nsteps:")         # 100 ns
ref_t   = W.FloatText(value=300.0, description="ref-T (K):")      # target temperature
tau_t   = W.FloatText(value=0.5, description="tau-T (ps):")       # thermostat coupling
ref_p   = W.FloatText(value=1.0, description="ref-P (bar):")      # target pressure
tau_p   = W.FloatText(value=5.0, description="tau-P (ps):")       # barostat coupling
pcoupl  = W.Dropdown(options=["Parrinello-Rahman","Berendsen","C-rescale"],
                     value="C-rescale", description="pcoupl:")
pcoupltype = W.Dropdown(options=["isotropic","semiisotropic","anisotropic"],
                        value="isotropic", description="pcoupltype:")

button  = W.Button(description="Write md.mdp", button_style="success")
out     = W.Output()

def write_file(_):
    text = f"""
; Production MD (NPT)
integrator      = md
dt              = {dt.value}
nsteps          = {nsteps.value}

; Output control
nstxout         = 0
nstvout         = 0
nstfout         = 0
nstlog          = 1000
nstenergy       = 1000
nstxout-compressed = 5000

; Neighbor searching & cutoffs
cutoff-scheme   = Verlet
nstlist         = 20
rcoulomb        = 1.0
rvdw            = 1.0
coulombtype     = PME

; Constraints
constraints     = h-bonds
lincs-iter      = 1
lincs-order     = 4

; Thermostat & Barostat
tcoupl          = V-rescale
tc-grps         = System
tau-t           = {tau_t.value}
ref-t           = {ref_t.value}

pcoupl          = {pcoupl.value}
pcoupltype      = {pcoupltype.value}
tau-p           = {tau_p.value}
ref-p           = {ref_p.value}
compressibility = 4.5e-5

; Misc
pbc             = xyz
DispCorr        = EnerPres
gen-vel         = no
; NOTE: Do NOT define POSRES here for production
"""
    path = os.path.join(PROJECT_DIR, "md.mdp")
    with open(path, "w") as f: f.write(text.strip()+"\n")
    out.clear_output()
    with out:
        display(Markdown(f"✅ **Saved:** `{path}`"))
        display(Markdown("```mdp\n"+text.strip()+"\n```"))

button.on_click(write_file)
display(W.VBox([dt,nsteps,ref_t,tau_t,ref_p,tau_p,pcoupl,pcoupltype,button,out]))

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# 
# # Running grompp
# gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md.tpr -po mdout.mdp
# 
# # Run mdrun with or without checkpoint
# if [ -f md.cpt ]; then
#   echo "[Resume] Found checkpoint md.cpt → resuming & appending"
#   gmx mdrun -deffnm md -v \
#             -cpi md.cpt -append \
#             -cpt 10 -cpo md.cpt \
#             -nb auto -pme gpu -pin off -ntmpi 1 -ntomp 2 \
#             -maxh 7.5
# else
#   echo "[Fresh run] No checkpoint found → starting new run"
#   gmx mdrun -deffnm md -v \
#             -cpt 10 -cpo md.cpt \
#             -nb auto -pme gpu -pin off -ntmpi 1 -ntomp 2 \
#             -maxh 7.5
# fi

# In case, disconnecet runtime for restarting for safety saving running files
from google.colab import drive
drive.flush_and_unmount()

# Commented out IPython magic to ensure Python compatibility.
# #@title **Center, Compact, Fit Trajectory**
# # Time-axis unwrapping (removal of periodic jumps)
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "System\nSystem\n" | gmx trjconv -s md.tpr -f md.xtc -pbc nojump -o md_nojump.xtc

# Commented out IPython magic to ensure Python compatibility.
# # Recentering and rewrapping with whole molecules
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Protein\nSystem\n" | gmx trjconv -s md.tpr -f md_nojump.xtc -center -pbc whole -o md_center.xtc

# Commented out IPython magic to ensure Python compatibility.
# # Rotational and translational fitting
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Backbone\nSystem\n" | gmx trjconv -s md.tpr -f md_center.xtc -fit rot+trans -o md_fit.xtc

# Commented out IPython magic to ensure Python compatibility.
# #@title **Diagnose minimum distance between Protein and Ligand**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# 
# # Ensure index.ndx exists with default groups and UNL group
# cat <<EOF | gmx make_ndx -f md.tpr -o index.ndx
# q
# r UNL
# q
# EOF

# Commented out IPython magic to ensure Python compatibility.
# #@title **Diagnose minimum distance between Protein and Ligand**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# 
# # Ensure index.ndx exists with default groups and UNL group
# cat <<EOF | gmx make_ndx -f md.tpr -o index.ndx
# q
# r UNL
# q
# EOF
# 
# # Use a large cutoff (e.g., 0.35 nm) to see if any close approaches are recorded
# # Provide group numbers 1 (Protein) and 13 (UNL) as input
# printf "1\n13\n" | gmx mindist -s md.tpr -f md.xtc -n index.ndx -od mindist.xvg -d 0.35

# Commented out IPython magic to ensure Python compatibility.
# #@title **RMSD analysis**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Backbone\nBackbone\n" | gmx rms -s md.tpr -f md_fit.xtc -o rmsd.xvg -tu ps

# Commented out IPython magic to ensure Python compatibility.
# #@title **RMSF analysis**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Backbone\n" | gmx rmsf -s md.tpr -f md_fit.xtc -o rmsf.xvg -res

# Commented out IPython magic to ensure Python compatibility.
# #@title **Rg analysis**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Protein\n" | gmx gyrate -s md.tpr -f md_fit.xtc -o gyrate.xvg

# Commented out IPython magic to ensure Python compatibility.
# #@title **H-bond analysis, using legacy**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# 
# # Make UNL-H group in ndx for analysis
# gmx select -s md.tpr -on index_hbond.ndx \
#   -select 'resname UNL and name "H*"'
# 
# gmx make_ndx -f md.tpr -o index_hbond.ndx << 'EOF'
# r UNL & a H*
# name 20 UNL-H
# l
# q
# EOF
# 
# # 1 = Protein, 13 = UNL ;Donor = 1 (Protein), Hydrogen = 2 (Protein-H), Acceptor = 13 (UNL)
# { printf "1\n13\n"; printf "1\n2\n13\n"; } | \
# gmx hbond-legacy -s md.tpr -f md_fit.xtc -n index_hbond.ndx -num hbond.xvg -tu ns

# Commented out IPython magic to ensure Python compatibility.
# #@title **SASA analysis for Protein**
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "Protein\n" | gmx sasa -s md.tpr -f md_fit.xtc -o sasa.xvg

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# source /usr/local/gromacs/bin/GMXRC
# printf "0\n" | gmx trjconv -s md.tpr -f md_fit.xtc -o chains.pdb -dump 100000
